{"version":3,"sources":["components/WordOptions.tsx","components/Options.tsx","components/Header.tsx","classes/LetterStack.ts","components/Letter.tsx","components/TypingTest.tsx","helpers/WPMHelper.ts","components/Timer.tsx","util/WordsToType.ts","util/WordArray.ts","components/Results.tsx","App.tsx","index.tsx"],"names":["wordOptions","WordOptions","updateNumOfWords","useState","showWords","setShowWords","onClick","className","map","wordOption","index","Options","Header","letterStack","capacity","Infinity","letter","this","size","Error","push","pop","length","Letter","letterText","letterState","TypingTest","currArrayOfArrayOfWords","updateWordArray","updateFinish","updateTestStart","initializeNewTest","currLetterStack","timeAtTestStart","Date","typingTest","useRef","restart","setRestart","isTyperFocused","setIsTyperFocused","currLetterPosition","currWordPosition","useEffect","typingTestRef","current","window","addEventListener","focus","setTimeout","onType","onFirstType","once","removeEventListener","event","key","getCurrentLetter","state","setLetterState","getCurrentWord","splice","peek","unshift","isEndOfWord","timeToFinishTest","getTime","ref","id","tabIndex","word","getNumOfCorrectCharacters","finishedWordArray","numOfCorrectCharacters","i","j","getNetWPM","Math","floor","Timer","currWordArray","testFinished","currentWPM","setCurrentWPM","interval","setInterval","console","log","clearInterval","randomWords","require","wordArray","getWordArray","numOfWords","words","exactly","maxLength","reduce","acc","cur","concat","getWords","charAt","Results","style","color","App","setCurrWordArray","timeToFinish","setTimeToFinish","setTestFinished","testStarted","setTestStarted","typerInstanceNumber","setTyperInstanceNumber","setNumOfWords","isFirstRender","testStart","updatedWordArray","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.63dacf5c.chunk.js","sourcesContent":["import React, { useState } from \"react\";\r\n\r\n\r\nconst wordOptions = [5, 10, 25, 50]\r\n\r\ninterface IWordOptionsProps {\r\n  updateNumOfWords: (numOfWords: number) => void\r\n}\r\n\r\n\r\nconst WordOptions: React.FC<IWordOptionsProps> = ({updateNumOfWords}) => {\r\n\r\n  const [showWords, setShowWords] = useState<boolean>(false)\r\n\r\n  return(\r\n    <li>\r\n      <span onClick={() => setShowWords(!showWords)}>words</span>\r\n      <div className=\"word-options\">\r\n        {showWords ? wordOptions.map((wordOption, index) => <div key={index} onClick={() => updateNumOfWords(wordOption)}>{wordOption}</div> ) : ''}\r\n      </div>\r\n    </li>\r\n  )\r\n} \r\n\r\nexport default WordOptions","import React, { useState } from \"react\";\r\nimport WordOptions from \"./WordOptions\";\r\n\r\ninterface IOptionsProps {\r\n  updateNumOfWords: (numOfWords: number) => void\r\n}\r\n\r\nconst Options: React.FC<IOptionsProps> = ({updateNumOfWords}) => {\r\n  \r\n\r\n  return(\r\n    <div className=\"options-wrapper\">\r\n        <ul className=\"options\">\r\n          <WordOptions updateNumOfWords={updateNumOfWords}/>\r\n        </ul>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default Options","import React from \"react\";\r\nimport Options from \"./Options\";\r\n\r\ninterface IHeaderProps {\r\n  updateNumOfWords: (numOfWords: number) => void\r\n}\r\n\r\nconst Header: React.FC<IHeaderProps> = ({updateNumOfWords}) => {\r\n\r\n  return(\r\n    <header className=\"header-container\">\r\n      <div className=\"title-wrapper\">\r\n        <h1>Camel Typer</h1>\r\n      </div>\r\n      <Options updateNumOfWords={updateNumOfWords}/>\r\n    </header>\r\n  )\r\n}\r\n\r\n\r\nexport default Header","\r\n\r\n\r\ninterface IStack<T> {\r\n  size(): number,\r\n  push(letter: T): void,\r\n  pop(): T | undefined,\r\n  peek(): T | undefined\r\n}\r\n\r\nexport default class letterStack<T> implements IStack<T> {\r\n\r\n  private letterStack: T[] = []\r\n  \r\n\r\n  constructor(private capacity: number = Infinity){}\r\n\r\n  push(letter: T) {\r\n    if(this.size() === this.capacity){\r\n      throw Error(\"Stack has reached maximum capacity\")\r\n    }\r\n    this.letterStack.push(letter)\r\n  }\r\n\r\n  pop(): T | undefined {\r\n    return this.letterStack.pop()\r\n  }\r\n\r\n  peek(): T | undefined {\r\n    return this.letterStack[this.size() - 1]\r\n  }\r\n\r\n  size(): number {\r\n    return this.letterStack.length\r\n  }\r\n\r\n  empty(): void {\r\n    this.letterStack = []\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n","import React from \"react\";\r\n\r\n\r\ninterface ILetterProps {\r\n  letterText: string,\r\n  letterState: string\r\n}\r\n\r\nconst Letter: React.FC<ILetterProps> = ({letterText, letterState}) => {\r\n\r\n  return(\r\n    <p className={`letter ${letterText === \" \" ? letterState === \"active\" ? letterState : \"\" : letterState}`} >\r\n      {letterText === \" \" ? <>&nbsp;</> : letterText}\r\n    </p>\r\n  )\r\n}\r\n\r\nexport default Letter","import React, { useState, useEffect, useRef, MutableRefObject } from \"react\";\r\nimport letterStack from \"../classes/LetterStack\";\r\nimport Letter from \"./Letter\";\r\nimport { arrayOfArrayOfWords } from \"../types/types\";\r\nimport {  FaRedoAlt } from \"react-icons/fa\"\r\n\r\n\r\ninterface ITypingTestProps {\r\n  currArrayOfArrayOfWords: arrayOfArrayOfWords,\r\n  updateWordArray: (currArray: arrayOfArrayOfWords) => void,\r\n  updateFinish: (timeToFinish: number) => void,\r\n  initializeNewTest: () => void,\r\n  updateTestStart: (testStart: boolean) => void\r\n}\r\n\r\n\r\n\r\nconst TypingTest: React.FC<ITypingTestProps> = ({ currArrayOfArrayOfWords,  updateWordArray, updateFinish, updateTestStart, initializeNewTest}) => {\r\n\r\n  /* char stack that keeps track of each letter the user inputs.\r\n  Pushes each pressed letter onto the stack then compares it to the correct input\r\n  based on currLetterPosition */\r\n  let currLetterStack = new letterStack<string>()\r\n  let timeAtTestStart = new Date('')\r\n  let typingTest = useRef() as MutableRefObject<HTMLDivElement>\r\n  const [restart, setRestart] = useState<boolean>(false)\r\n  const [isTyperFocused, setIsTyperFocused] = useState<boolean>(false)\r\n  /* Tracks the position of the word and letter that is next expected to be input from the user.\r\n  Is either incremented/decremented based on the user's input */\r\n  let currLetterPosition = useRef(0)\r\n  let currWordPosition = useRef(0)\r\n  useEffect(() => {\r\n\r\n    let typingTestRef = typingTest.current\r\n\r\n    const setupListeners = () => {\r\n      window.addEventListener(\"keypress\", () => {\r\n        if(!isTyperFocused){\r\n          typingTestRef.focus()\r\n          setIsTyperFocused(true)\r\n        }\r\n      })\r\n      window.addEventListener(\"click\", () => {\r\n        setTimeout(() => {\r\n            setIsTyperFocused(false)\r\n        }, 1000)\r\n      })\r\n      typingTestRef.addEventListener(\"keydown\", onType)\r\n      typingTestRef.addEventListener(\"keydown\", onFirstType, {once: true})\r\n    }\r\n    \r\n    setupListeners()\r\n\r\n    return () => {\r\n      setIsTyperFocused(true)\r\n      typingTestRef.removeEventListener(\"keydown\", onType)\r\n      currLetterPosition.current = 0\r\n      currWordPosition.current = 0\r\n    }\r\n    \r\n  }, [restart])\r\n\r\n  const onFirstType = () => {\r\n    timeAtTestStart = new Date()\r\n    updateTestStart(true)\r\n  }\r\n\r\n  // Event listener to listen for any keypress that occurs, including ones that do not produce printable characters\r\n  const onType = (event: any) => {\r\n    \r\n    // Pushes the letter that was input by the user to the currLetterStack, so it can be compared to the correct array\r\n    currLetterStack.push(event.key)\r\n    if(event.key === 'Backspace'){\r\n      // If we are at the first letter of the first word, don't do anything\r\n      if(currWordPosition.current === 0 && currLetterPosition.current === 0)\r\n        return\r\n      \r\n      // If the current letter is an extra incorrect letter, reset its state.\r\n      getCurrentLetter().state === \"incorrectTemp\" ? getCurrentLetter() : setLetterState(\"\")\r\n      // If we're at the first letter of a word\r\n      if(currLetterPosition.current === 0){\r\n        // Go back to the previous word\r\n        currWordPosition.current--\r\n        // Position the current letter at the end of that previous word\r\n        currLetterPosition.current = getCurrentWord().length\r\n      }\r\n      // If not, go back to the previous letter normally\r\n      currLetterPosition.current--\r\n\r\n      if(getCurrentLetter().state === \"incorrectTemp\"){\r\n        getCurrentWord().splice(currLetterPosition.current, 1)\r\n      }\r\n\r\n      getCurrentLetter().state === \"incorrectTemp\" ? getCurrentLetter() : setLetterState(\"active\")\r\n      // Removes the letter that is to be erased from the currLetterStack\r\n      currLetterStack.pop()\r\n      updateWordArray([...currArrayOfArrayOfWords])\r\n      return\r\n    }\r\n    else if(currLetterStack.peek() === getCurrentLetter().letterText){\r\n      setLetterState(\"correct\")\r\n      updateWordArray([...currArrayOfArrayOfWords])\r\n    }\r\n    else{\r\n      if(currLetterStack.peek() === \" \" && (currWordPosition.current !== currArrayOfArrayOfWords.length - 1)){\r\n        getCurrentLetter().state = \"\"\r\n        currWordPosition.current++\r\n        currLetterPosition.current = 0\r\n      }\r\n      else if(getCurrentLetter().letterText === \" \"){\r\n        currArrayOfArrayOfWords[currWordPosition.current].unshift({\r\n          letterText: event.key,\r\n           state: \"incorrectTemp\",\r\n            isEndOfWord: false\r\n          })\r\n      }\r\n      else{\r\n        setLetterState(\"incorrect\")\r\n      }\r\n      updateWordArray([...currArrayOfArrayOfWords])\r\n    }\r\n    \r\n    \r\n    if(getCurrentLetter().isEndOfWord){\r\n      // If we're not on the last word\r\n      if(currArrayOfArrayOfWords.length - 1 !== currWordPosition.current){\r\n        currWordPosition.current++\r\n        currLetterPosition.current = 0\r\n      }\r\n      // If we are, do not jump to the last word.\r\n      else{\r\n        // This increment exists so we can identify if we are on the last letter of the last word.\r\n        currLetterPosition.current++\r\n      }\r\n    }\r\n    else{\r\n      currLetterPosition.current++\r\n    }\r\n\r\n    // If the user is on the last word\r\n    if(currArrayOfArrayOfWords.length - 1 === currWordPosition.current){\r\n      // and they have just input the last letter\r\n      if(getCurrentWord().length === currLetterPosition.current){\r\n        /* This line might seem redundant since we are removing the event listener on unmount through useEffect.\r\n           However, this actually addresses an edge case where if the user is giving keyboard input extremely fast,\r\n           they could access onType between the time the test ends, until it is unmounted, thus throwing an error. */\r\n        window.removeEventListener(\"keydown\", onType)\r\n        const timeToFinishTest =  ((new Date().getTime() - timeAtTestStart.getTime()) / 1000)\r\n        // Updates 'finish' state in parent component\r\n        updateFinish(timeToFinishTest)\r\n      }\r\n      else{\r\n        setLetterState(\"active\")\r\n        updateWordArray([...currArrayOfArrayOfWords])\r\n      }\r\n    }\r\n    else{\r\n        setLetterState(\"active\")\r\n        updateWordArray([...currArrayOfArrayOfWords])\r\n    }\r\n    \r\n    \r\n  }\r\n\r\n  const setLetterState = (state: string) => {\r\n    currArrayOfArrayOfWords[currWordPosition.current][currLetterPosition.current].state = state\r\n  }\r\n\r\n  const getCurrentLetter = () => {\r\n    return currArrayOfArrayOfWords[currWordPosition.current][currLetterPosition.current]\r\n  }\r\n\r\n  const getCurrentWord = () => {\r\n    return currArrayOfArrayOfWords[currWordPosition.current]\r\n  }\r\n\r\n  const restartTest = () => {\r\n    typingTest.current.focus()\r\n    currLetterPosition.current = 0\r\n    currWordPosition.current = 0\r\n    setRestart(!restart)\r\n    initializeNewTest()\r\n    updateTestStart(false)\r\n  }\r\n\r\n  return(\r\n    <div className=\"center-of-mid typer-container\">\r\n      {isTyperFocused ? '' : <h3>Press any key to focus</h3> }\r\n      <div ref={typingTest} id=\"test\" tabIndex={0} className=\"word-container-wrapper\">\r\n        <div className={`word-container ${isTyperFocused ? '' : 'unfocused'}`}>\r\n          {currArrayOfArrayOfWords.map((word, index) => \r\n            <div key={index} className=\"word\">\r\n              {word.map((letter, index) => <Letter key={index} letterText={letter.letterText} letterState={letter.state} />  )}\r\n            </div> )}\r\n        </div>\r\n      </div> \r\n      <button onClick={restartTest} className=\"restart-btn\">\r\n        restart\r\n      </button>\r\n    </div>\r\n  )\r\n}\r\n\r\n\r\nexport default TypingTest","import { arrayOfArrayOfWords } from \"../types/types\";\r\n\r\nexport const getNumOfCorrectAndIncorrectCharacters = (finishedWordArray: arrayOfArrayOfWords) => {\r\n  let NumOfCorrectAndIncorrectCharacters = 0\r\n  for(let i = 0; i < finishedWordArray.length; i++){\r\n    for(let j = 0; j < finishedWordArray[i].length; j++){\r\n      if(finishedWordArray[i][j].state === \"correct\" || finishedWordArray[i][j].state === \"incorrect\")\r\n        NumOfCorrectAndIncorrectCharacters++\r\n    }   \r\n  }\r\n  return NumOfCorrectAndIncorrectCharacters\r\n}\r\n\r\nexport const getNumOfCorrectCharacters = (finishedWordArray: arrayOfArrayOfWords) => {\r\n  let numOfCorrectCharacters = 0\r\n  for(let i = 0; i < finishedWordArray.length; i++){\r\n    for(let j = 0; j < finishedWordArray[i].length; j++){\r\n      if(finishedWordArray[i][j].state === \"correct\")\r\n        numOfCorrectCharacters++\r\n    }\r\n  }\r\n  return numOfCorrectCharacters\r\n}\r\n\r\nexport const getNetWPM = (timeToFinishTest: number, finishedWordArray: arrayOfArrayOfWords) => {\r\n  return Math.floor((getNumOfCorrectCharacters(finishedWordArray) / (timeToFinishTest / 60)) / 5)\r\n}\r\n\r\nexport const getGrossWPM = (timeToFinishTest: number, finishedWordArray: arrayOfArrayOfWords) => {\r\n  return Math.floor((getNumOfCorrectAndIncorrectCharacters(finishedWordArray) / (timeToFinishTest / 60)) / 5)\r\n}\r\n","import { clear } from \"console\";\r\nimport React, { useEffect, useRef, useState } from \"react\";\r\nimport { getNetWPM, getNumOfCorrectCharacters } from \"../helpers/WPMHelper\"\r\nimport { arrayOfArrayOfWords } from \"../types/types\";\r\n\r\ninterface ITimerProps {\r\n  currWordArray: arrayOfArrayOfWords,\r\n  testFinished: boolean\r\n}\r\n\r\nconst Timer: React.FC<ITimerProps> = ({currWordArray, testFinished}) => {\r\n\r\n  const [currentWPM, setCurrentWPM] = useState<number>(0)\r\n  let interval = useRef(0)\r\n\r\n  useEffect(() => {\r\n    \r\n    let timeAtTestStart = new Date()\r\n    if(!testFinished){\r\n        interval.current = window.setInterval(() => {\r\n        setCurrentWPM(  getNetWPM(  ((new Date().getTime() - timeAtTestStart.getTime()) / 1000), currWordArray  )  )\r\n      }, 700)\r\n    }\r\n\r\n    return () => {\r\n      console.log(getNumOfCorrectCharacters(currWordArray));\r\n      console.log(new Date().getTime() - timeAtTestStart.getTime());\r\n      clearInterval(interval.current)\r\n    }\r\n  }, [])\r\n\r\n  return(\r\n    <div className=\"timer\">\r\n      <h1>{currentWPM}</h1>\r\n    </div>\r\n  )\r\n\r\n}\r\n\r\nexport default Timer\r\n","const randomWords = require('random-words')\r\n\r\nexport const getWords = (numOfWords: number) => {\r\n  let words = randomWords({ exactly: numOfWords, maxLength: 6 })\r\n  // Adds a space at the beginning, end and in between each element of the array of words\r\n  words = words.reduce((acc: string[], cur: string) => acc.concat(cur, \" \"), [\" \"])\r\n  // Remove the first and last space in the array, respectively\r\n  words.splice(0, 1)\r\n  words.splice(words.length - 1, 1)\r\n  return words\r\n}","import { getWords } from \"./WordsToType\"\r\n\r\nvar wordArray: {letterText: string, state: string, isEndOfWord: boolean}[][] = []\r\n\r\nexport const getWordArray = (numOfWords: number) => {\r\n   var words = getWords(numOfWords)\r\n   wordArray = []\r\n  for(let i = 0; i < words.length; i++){\r\n    wordArray[i] = []\r\n    for(let j = 0; j < words[i].length; j++){\r\n      wordArray[i].push({letterText: words[i].charAt(j),\r\n         state: \"\",\r\n         isEndOfWord: words[i].charAt(j+1) === \"\" ? true : false })\r\n    }\r\n  }\r\n  return wordArray\r\n }\r\n\r\n","import React from \"react\";\r\nimport { getNetWPM } from \"../helpers/WPMHelper\"\r\nimport { IWPMProps as IResultsProps } from \"../interfaces/commonProps\"\r\n\r\nconst Results: React.FC<IResultsProps> = ({finishedWordArray, timeToFinishTest, initializeNewTest}) => {\r\n\r\n  \r\n  return(\r\n    <div className=\"center-of-mid results-container\">\r\n      <div className=\"wpm-container\">\r\n        <h1>WPM <span style={{color: \"orange\"}}>{getNetWPM(timeToFinishTest, finishedWordArray)}</span> </h1>\r\n      </div>\r\n      <button className=\"new-test-btn\" onClick={initializeNewTest} >Go again?</button>\r\n    </div>\r\n  )\r\n\r\n  \r\n}\r\n\r\nexport default Results","import React, { useEffect, useRef, useState } from 'react';\nimport Header from './components/Header'\nimport Typer from './components/TypingTest';\nimport Timer from './components/Timer'\nimport { getWordArray } from \"./util/WordArray\"\nimport { arrayOfArrayOfWords } from \"./types/types\";\nimport Results from './components/Results';\n\nconst wordArray = getWordArray(20)\n\nconst App: React.FC = () => {\n\n  const [currWordArray, setCurrWordArray] = useState<arrayOfArrayOfWords>(wordArray)\n  const [timeToFinish, setTimeToFinish] = useState<number>(0)\n  const [testFinished, setTestFinished] = useState<boolean>(false)\n  const [testStarted, setTestStarted] = useState<boolean>(false)\n  const [typerInstanceNumber, setTyperInstanceNumber] = useState<number>(1)\n  const [numOfWords, setNumOfWords] = useState<number>(20)\n\n  const isFirstRender = useRef(true)\n\n  useEffect(() => {\n    isFirstRender.current ? isFirstRender.current = false : initializeNewTest()\n  }, [numOfWords])\n\n  const initializeNewTest = () => {\n    setTyperInstanceNumber(typerInstanceNumber + 1)\n    setCurrWordArray(getWordArray(numOfWords))\n    setTestFinished(false)\n    setTestStarted(false)\n  }\n \n  const updateNumOfWords = (numOfWords: number) => {\n    setNumOfWords(numOfWords)\n    setTestStarted(false)\n  }\n\n  const updateTestStart =  (testStart: boolean) => setTestStarted(testStart)\n  \n\n  const updateWordArray = (updatedWordArray: arrayOfArrayOfWords) => setCurrWordArray(updatedWordArray)\n  \n\n  const updateFinish = (timeToFinish: number) => {\n    setTimeToFinish(timeToFinish)\n    setTestFinished(true)\n    setTestStarted(false)\n  }\n\n  return (\n    <div className=\"container\">\n      <div className=\"mid-container\">\n      <Header updateNumOfWords={updateNumOfWords}/>\n      {testStarted ? <Timer testFinished={testFinished} currWordArray={currWordArray} /> : \"\" }\n      {testFinished ? \n        <Results  initializeNewTest={initializeNewTest} timeToFinishTest={timeToFinish}\n          finishedWordArray={currWordArray} /> \n          :\n        <Typer key={typerInstanceNumber}\n          currArrayOfArrayOfWords={currWordArray} \n            updateTestStart={updateTestStart}\n              updateWordArray={updateWordArray} \n                updateFinish={updateFinish}\n                  initializeNewTest={initializeNewTest} />\n      }\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}