{"version":3,"sources":["components/WordOptions.tsx","components/Options.tsx","components/Header.tsx","classes/LetterStack.ts","components/Letter.tsx","helpers/WPMHelper.ts","components/Timer.tsx","components/TypingTest.tsx","util/WordsToType.ts","util/WordArray.ts","components/Results.tsx","App.tsx","index.tsx"],"names":["wordOptions","WordOptions","updateNumOfWords","useState","showWords","setShowWords","onClick","className","map","wordOption","index","Options","Header","letterStack","capacity","Infinity","letter","this","size","Error","push","pop","length","Letter","letterText","letterState","getNetWPM","timeToFinishTest","finishedWordArray","Math","floor","numOfCorrectCharacters","i","j","state","getNumOfCorrectCharacters","Timer","currWordArray","testFinished","currentWPM","setCurrentWPM","interval","useRef","useEffect","timeAtTestStart","Date","current","window","setInterval","getTime","clearInterval","TypingTest","currArrayOfArrayOfWords","testStarted","updateWordArray","updateFinish","updateTestStart","initializeNewTest","currLetterStack","typingTest","restart","setRestart","isTyperFocused","setIsTyperFocused","currLetterPosition","currWordPosition","typingTestRef","addEventListener","focus","setTimeout","onType","onFirstType","once","removeEventListener","event","key","peek","getCurrentLetter","setLetterState","getCurrentWord","splice","isLastWord","isEndOfWord","ref","id","tabIndex","style","opacity","word","randomWords","require","wordArray","getWordArray","numOfWords","words","exactly","maxLength","reduce","acc","cur","concat","getWords","charAt","Results","color","App","setCurrWordArray","timeToFinish","setTimeToFinish","setTestFinished","setTestStarted","typerInstanceNumber","setTyperInstanceNumber","setNumOfWords","testStart","updatedWordArray","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.0830cf2a.chunk.js","sourcesContent":["import React, { useState } from \"react\";\r\n\r\n\r\nconst wordOptions = [5, 10, 25, 50]\r\n\r\ninterface IWordOptionsProps {\r\n  updateNumOfWords: (numOfWords: number) => void\r\n}\r\n\r\n\r\nconst WordOptions: React.FC<IWordOptionsProps> = ({updateNumOfWords}) => {\r\n\r\n  const [showWords, setShowWords] = useState<boolean>(false)\r\n\r\n  return(\r\n    <li>\r\n      <span onClick={() => setShowWords(!showWords)}>words</span>\r\n      <div className=\"word-options\">\r\n        {showWords ? wordOptions.map((wordOption, index) => <div key={index} onClick={() => updateNumOfWords(wordOption)}>{wordOption}</div> ) : ''}\r\n      </div>\r\n    </li>\r\n  )\r\n} \r\n\r\nexport default WordOptions","import React, { useState } from \"react\";\r\nimport WordOptions from \"./WordOptions\";\r\n\r\ninterface IOptionsProps {\r\n  updateNumOfWords: (numOfWords: number) => void\r\n}\r\n\r\nconst Options: React.FC<IOptionsProps> = ({updateNumOfWords}) => {\r\n  \r\n\r\n  return(\r\n    <div className=\"options-wrapper\">\r\n        <ul className=\"options\">\r\n          <WordOptions updateNumOfWords={updateNumOfWords}/>\r\n        </ul>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default Options","import React from \"react\";\r\nimport Options from \"./Options\";\r\n\r\ninterface IHeaderProps {\r\n  updateNumOfWords: (numOfWords: number) => void\r\n}\r\n\r\nconst Header: React.FC<IHeaderProps> = ({updateNumOfWords}) => {\r\n\r\n  return(\r\n    <header className=\"header-container\">\r\n      <div className=\"title-wrapper\">\r\n        <h1>camelType</h1>\r\n      </div>\r\n      <Options updateNumOfWords={updateNumOfWords}/>\r\n    </header>\r\n  )\r\n}\r\n\r\n\r\nexport default Header","\r\n\r\n\r\ninterface IStack<T> {\r\n  size(): number,\r\n  push(letter: T): void,\r\n  pop(): T | undefined,\r\n  peek(): T | undefined\r\n}\r\n\r\nexport default class letterStack<T> implements IStack<T> {\r\n\r\n  private letterStack: T[] = []\r\n  \r\n\r\n  constructor(private capacity: number = Infinity){}\r\n\r\n  push(letter: T) {\r\n    if(this.size() === this.capacity){\r\n      throw Error(\"Stack has reached maximum capacity\")\r\n    }\r\n    this.letterStack.push(letter)\r\n  }\r\n\r\n  pop(): T | undefined {\r\n    return this.letterStack.pop()\r\n  }\r\n\r\n  peek(): T | undefined {\r\n    return this.letterStack[this.size() - 1]\r\n  }\r\n\r\n  size(): number {\r\n    return this.letterStack.length\r\n  }\r\n\r\n  empty(): void {\r\n    this.letterStack = []\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n","import React from \"react\";\r\n\r\n\r\ninterface ILetterProps {\r\n  letterText: string,\r\n  letterState: string\r\n}\r\n\r\nconst Letter: React.FC<ILetterProps> = ({letterText, letterState}) => {\r\n\r\n  return(\r\n    <p className={`letter ${letterText === \" \" ? letterState === \"active\" ? letterState : \"\" : letterState}`} >\r\n      {letterText === \" \" ? <>&nbsp;</> : letterText}\r\n    </p>\r\n  )\r\n}\r\n\r\nexport default Letter","import { arrayOfArrayOfWords } from \"../types/types\";\r\n\r\nexport const getNumOfCharacters = (finishedWordArray: arrayOfArrayOfWords) => {\r\n  let NumOfCorrectAndIncorrectCharacters = 0\r\n  for(let i = 0; i < finishedWordArray.length; i++){\r\n    for(let j = 0; j < finishedWordArray[i].length; j++){\r\n      if(finishedWordArray[i][j].state === \"correct\" || finishedWordArray[i][j].state === \"incorrect\")\r\n        NumOfCorrectAndIncorrectCharacters++\r\n    }   \r\n  }\r\n  return NumOfCorrectAndIncorrectCharacters\r\n}\r\n\r\nexport const getNumOfCorrectCharacters = (finishedWordArray: arrayOfArrayOfWords) => {\r\n  let numOfCorrectCharacters = 0\r\n  for(let i = 0; i < finishedWordArray.length; i++){\r\n    for(let j = 0; j < finishedWordArray[i].length; j++){\r\n      if(finishedWordArray[i][j].state === \"correct\")\r\n        numOfCorrectCharacters++\r\n    }\r\n  }\r\n  return numOfCorrectCharacters\r\n}\r\n\r\nexport const getNetWPM = (timeToFinishTest: number, finishedWordArray: arrayOfArrayOfWords) => {\r\n  return Math.floor((getNumOfCorrectCharacters(finishedWordArray) / (timeToFinishTest / 60)) / 5)\r\n}\r\n\r\nexport const getGrossWPM = (timeToFinishTest: number, finishedWordArray: arrayOfArrayOfWords) => {\r\n  return Math.floor((getNumOfCharacters(finishedWordArray) / (timeToFinishTest / 60)) / 5)\r\n}\r\n","import React, { useEffect, useRef, useState } from \"react\";\r\nimport { getNetWPM} from \"../helpers/WPMHelper\"\r\nimport { arrayOfArrayOfWords } from \"../types/types\";\r\n\r\ninterface ITimerProps {\r\n  currWordArray: arrayOfArrayOfWords,\r\n  testFinished: boolean\r\n}\r\n\r\nconst Timer: React.FC<ITimerProps> = ({currWordArray, testFinished}) => {\r\n\r\n  const [currentWPM, setCurrentWPM] = useState<number>(0)\r\n  let interval = useRef(0)\r\n\r\n  useEffect(() => {\r\n    \r\n    let timeAtTestStart = new Date()\r\n    if(!testFinished){\r\n        interval.current = window.setInterval(() => {\r\n        setCurrentWPM(  getNetWPM(  ((new Date().getTime() - timeAtTestStart.getTime()) / 1000), currWordArray  )  )\r\n      }, 700)\r\n    }\r\n\r\n    return () => {\r\n      clearInterval(interval.current)\r\n    }\r\n    \r\n  }, [])\r\n\r\n  return(\r\n    <div className=\"timer\">\r\n      <h1>WPM: {currentWPM}</h1>\r\n    </div>\r\n  )\r\n\r\n}\r\n\r\nexport default Timer\r\n","import React, { useState, useEffect, useRef, MutableRefObject } from \"react\";\r\nimport letterStack from \"../classes/LetterStack\";\r\nimport Letter from \"./Letter\";\r\nimport Timer from \"./Timer\";\r\nimport { arrayOfArrayOfWords } from \"../types/types\";\r\n\r\n\r\ninterface ITypingTestProps {\r\n  currArrayOfArrayOfWords: arrayOfArrayOfWords,\r\n  updateWordArray: (currArray: arrayOfArrayOfWords) => void,\r\n  updateFinish: (timeToFinish: number) => void,\r\n  initializeNewTest: () => void,\r\n  updateTestStart: (testStart: boolean) => void,\r\n  testFinished: boolean,\r\n  testStarted: boolean\r\n}\r\n\r\n\r\n\r\nconst TypingTest: React.FC<ITypingTestProps> = ({ currArrayOfArrayOfWords, testFinished, testStarted,  updateWordArray, updateFinish, updateTestStart, initializeNewTest}) => {\r\n\r\n  /* char stack that keeps track of each letter the user inputs.\r\n  Pushes each pressed letter onto the stack then compares it to the correct input\r\n  based on currLetterPosition */\r\n  let currLetterStack = new letterStack<string>()\r\n  let timeAtTestStart = new Date('')\r\n  let typingTest = useRef() as MutableRefObject<HTMLDivElement>\r\n  const [restart, setRestart] = useState<boolean>(false)\r\n  const [isTyperFocused, setIsTyperFocused] = useState<boolean>(false)\r\n  /* Tracks the position of the word and letter that is next expected to be input from the user.\r\n  Is either incremented/decremented based on the user's input */\r\n  let currLetterPosition = useRef(0)\r\n  let currWordPosition = useRef(0)\r\n  useEffect(() => {\r\n\r\n    let typingTestRef = typingTest.current\r\n\r\n    const setupListeners = () => {\r\n      window.addEventListener(\"keypress\", () => {\r\n        if(!isTyperFocused){\r\n          typingTestRef.focus()\r\n          setIsTyperFocused(true)\r\n        }\r\n      })\r\n      window.addEventListener(\"click\", () => {\r\n        setTimeout(() => {\r\n            setIsTyperFocused(false)\r\n        }, 1000)\r\n      })\r\n      typingTestRef.addEventListener(\"keydown\", onType)\r\n      typingTestRef.addEventListener(\"keydown\", onFirstType, {once: true})\r\n\r\n      // For mobile devices\r\n      typingTestRef.addEventListener(\"touchstart\", onType)\r\n      typingTestRef.addEventListener(\"touchstart\", onFirstType, {once: true})\r\n    }\r\n    \r\n    setupListeners()\r\n\r\n    return () => {\r\n      setIsTyperFocused(true)\r\n      typingTestRef.removeEventListener(\"keydown\", onType)\r\n      typingTestRef.removeEventListener(\"touchstart\", onType)\r\n      currLetterPosition.current = 0\r\n      currWordPosition.current = 0\r\n    }\r\n    \r\n  }, [restart])\r\n\r\n  const onFirstType = () => {\r\n    timeAtTestStart = new Date()\r\n    updateTestStart(true)\r\n  }\r\n\r\n  // Event listener to listen for any keypress that occurs, including ones that do not produce printable characters\r\n  const onType = (event: any) => {\r\n    \r\n    // Pushes the letter that was input by the user to the currLetterStack, so it can be compared to the correct array\r\n    currLetterStack.push(event.key)\r\n    if(currLetterStack.peek() === \"Backspace\"){\r\n      // If we are at the first letter of the first word, don't do anything\r\n      if(currWordPosition.current === 0 && currLetterPosition.current === 0)\r\n        return\r\n      \r\n      // If the current letter is not an extra incorrect letter, reset its state.\r\n      getCurrentLetter().state === \"incorrectTemp\" ? getCurrentLetter() : setLetterState(\"\")\r\n      // If we're at the first letter of a word\r\n      if(currLetterPosition.current === 0){\r\n        // Go back to the previous word\r\n        currWordPosition.current--\r\n        // Position the current letter at the end of that previous word\r\n        currLetterPosition.current = getCurrentWord().length\r\n      }\r\n      // If not, go back to the previous letter normally\r\n      currLetterPosition.current--\r\n\r\n      if(getCurrentLetter().state === \"incorrectTemp\"){\r\n        getCurrentWord().splice(currLetterPosition.current, 1)\r\n      }\r\n\r\n      getCurrentLetter().state === \"incorrectTemp\" ? getCurrentLetter() : setLetterState(\"active\")\r\n      // Removes the letter that is to be erased from the currLetterStack\r\n      currLetterStack.pop()\r\n      updateWordArray([...currArrayOfArrayOfWords])\r\n      return\r\n    }\r\n    else if(currLetterStack.peek() === getCurrentLetter().letterText){\r\n      setLetterState(\"correct\")\r\n      updateWordArray([...currArrayOfArrayOfWords])\r\n    }\r\n    else{\r\n      // If a space was incorrectly entered and we are not on the last word of the test.\r\n      if(currLetterStack.peek() === \" \" && !isLastWord() ){\r\n        getCurrentLetter().state = \"\"\r\n        currWordPosition.current++\r\n        currLetterPosition.current = 0\r\n      }\r\n      // If we're on a space character\r\n      else if(getCurrentLetter().letterText === \" \"){\r\n        // Adds the incorrect temp letter before the last element (the space) of the current word array\r\n        getCurrentWord().splice(getCurrentWord().length - 1, 0,{\r\n          letterText: event.key,\r\n           state: \"incorrectTemp\",\r\n            isEndOfWord: false\r\n          })\r\n      }\r\n      else{\r\n        setLetterState(\"incorrect\")\r\n      }\r\n      updateWordArray([...currArrayOfArrayOfWords])\r\n    }\r\n    \r\n    \r\n    if(getCurrentLetter().isEndOfWord){\r\n      // If we're not on the last word\r\n      if(!isLastWord()){\r\n        currWordPosition.current++\r\n        currLetterPosition.current = 0\r\n      }\r\n      // If we are, do not jump to the last word.\r\n      else{\r\n        // This increment exists so we can identify if we are on the last letter of the last word.\r\n        currLetterPosition.current++\r\n      }\r\n    }\r\n    else{\r\n      currLetterPosition.current++\r\n    }\r\n\r\n    // If the user is on the last word\r\n    if(isLastWord()){\r\n      // and they have just input the last letter\r\n      if(getCurrentWord().length === currLetterPosition.current){\r\n        /* This line might seem redundant since we are removing the event listener on unmount through useEffect.\r\n           However, this actually addresses an edge case where if the user is giving keyboard input extremely fast,\r\n           they could access onType between the time the test ends, until it is unmounted, thus throwing an error. */\r\n        window.removeEventListener(\"keydown\", onType)\r\n        const timeToFinishTest =  ((new Date().getTime() - timeAtTestStart.getTime()) / 1000)\r\n        // Updates 'finish' state in parent component\r\n        updateFinish(timeToFinishTest)\r\n      }\r\n    }\r\n    setLetterState(\"active\")\r\n    updateWordArray([...currArrayOfArrayOfWords])\r\n    \r\n    \r\n  }\r\n\r\n  const setLetterState = (state: string) => {\r\n    currArrayOfArrayOfWords[currWordPosition.current][currLetterPosition.current].state = state\r\n  }\r\n\r\n  const getCurrentLetter = () => {\r\n    return currArrayOfArrayOfWords[currWordPosition.current][currLetterPosition.current]\r\n  }\r\n\r\n  const getCurrentWord = () => {\r\n    return currArrayOfArrayOfWords[currWordPosition.current]\r\n  }\r\n  \r\n  const isLastWord = () => currArrayOfArrayOfWords.length - 1 === currWordPosition.current\r\n\r\n  const restartTest = () => {\r\n    typingTest.current.focus()\r\n    currLetterPosition.current = 0\r\n    currWordPosition.current = 0\r\n    setRestart(!restart)\r\n    initializeNewTest()\r\n    updateTestStart(false)\r\n  }\r\n\r\n  return(\r\n    <div className=\"center-of-mid typer-container\">\r\n\r\n      {isTyperFocused ? <div className=\"focus-instruction evaporated\">Press any key to focus</div> : \r\n      <div className=\"focus-instruction\">Press any key to focus</div> }\r\n\r\n\r\n      <div ref={typingTest} id=\"test\" tabIndex={0} className=\"word-container-wrapper\">\r\n\r\n        { testStarted ? <Timer testFinished={testFinished} currWordArray={currArrayOfArrayOfWords} /> : \r\n          // Placeholder to account for the size of the WPM counter when it's displayed\r\n          <div className=\"timer\">\r\n            <h1 style={{opacity: 0}}>placeholder</h1>\r\n          </div>\r\n        }\r\n\r\n        <div className={`word-container ${isTyperFocused ? '' : 'unfocused'}`}>\r\n\r\n          { currArrayOfArrayOfWords.map((word, index) => \r\n\r\n            <div key={index} className=\"word\">\r\n\r\n              {word.map((letter, index) => <Letter key={index} letterText={letter.letterText} letterState={letter.state} />  )}\r\n\r\n            </div> )\r\n\r\n          }\r\n\r\n        </div>\r\n\r\n      </div> \r\n\r\n      <button onClick={restartTest} className=\"restart-btn\">\r\n        restart\r\n      </button>\r\n\r\n    </div>\r\n  )\r\n}\r\n\r\n\r\nexport default TypingTest","const randomWords = require('random-words')\r\n\r\nexport const getWords = (numOfWords: number) => {\r\n  let words = randomWords({ exactly: numOfWords, maxLength: 6 })\r\n  // Adds a space at the beginning, end and in between each element of the array of words\r\n  words = words.reduce((acc: string[], cur: string) => acc.concat(cur, \" \"), [])\r\n  // Remove last space in the array\r\n  words.splice(words.length - 1, 1)\r\n  return words\r\n}","import { getWords } from \"./WordsToType\"\r\n\r\nlet wordArray: {letterText: string, state: string, isEndOfWord: boolean}[][] = []\r\n\r\nexport const getWordArray = (numOfWords: number) => {\r\n   let words = getWords(numOfWords)\r\n   wordArray = []\r\n  for(let i = 0; i < words.length; i++){\r\n    wordArray[i] = []\r\n    for(let j = 0; j < words[i].length; j++){\r\n      wordArray[i].push({\r\n         letterText: words[i].charAt(j),\r\n         state: \"\",\r\n         isEndOfWord: words[i].charAt(j+1) === \"\" ? true : false \r\n        })\r\n    }\r\n  }\r\n  return wordArray\r\n }\r\n\r\n","import React from \"react\";\r\nimport { getNetWPM } from \"../helpers/WPMHelper\"\r\nimport { IWPMProps as IResultsProps } from \"../interfaces/commonProps\"\r\n\r\nconst Results: React.FC<IResultsProps> = ({finishedWordArray, timeToFinishTest, initializeNewTest}) => {\r\n\r\n  \r\n  return(\r\n    <div className=\"center-of-mid results-container\">\r\n      <div className=\"wpm-container\">\r\n        <h1>WPM <span style={{color: \"orange\"}}>{getNetWPM(timeToFinishTest, finishedWordArray)}</span> </h1>\r\n      </div>\r\n      <button className=\"new-test-btn\" onClick={initializeNewTest} >Go again?</button>\r\n    </div>\r\n  )\r\n\r\n  \r\n}\r\n\r\nexport default Results","import React, { useEffect, useState } from 'react';\nimport Header from './components/Header'\nimport Typer from './components/TypingTest';\nimport { getWordArray } from \"./util/WordArray\"\nimport { arrayOfArrayOfWords } from \"./types/types\";\nimport Results from './components/Results';\n\n\nconst App: React.FC = () => {\n\n  const [currWordArray, setCurrWordArray] = useState<arrayOfArrayOfWords>(getWordArray(20))\n  const [timeToFinish, setTimeToFinish] = useState<number>(0)\n  const [testFinished, setTestFinished] = useState<boolean>(false)\n  const [testStarted, setTestStarted] = useState<boolean>(false)\n  const [typerInstanceNumber, setTyperInstanceNumber] = useState<number>(1)\n  const [numOfWords, setNumOfWords] = useState<number>(20)\n\n  useEffect(() => {\n    initializeNewTest()\n  }, [numOfWords])\n\n  const initializeNewTest = () => {\n    setTyperInstanceNumber(typerInstanceNumber + 1)\n    setCurrWordArray(getWordArray(numOfWords))\n    setTestFinished(false)\n    setTestStarted(false)\n  }\n \n  const updateNumOfWords = (numOfWords: number) => {\n    setNumOfWords(numOfWords)\n    setTestStarted(false)\n  }\n\n  const updateTestStart =  (testStart: boolean) => setTestStarted(testStart)\n  \n\n  const updateWordArray = (updatedWordArray: arrayOfArrayOfWords) => setCurrWordArray(updatedWordArray)\n  \n\n  const updateFinish = (timeToFinish: number) => {\n    setTimeToFinish(timeToFinish)\n    setTestFinished(true)\n    setTestStarted(false)\n  }\n\n  return (\n    <div className=\"container\">\n      <div className=\"mid-container\">\n      <Header updateNumOfWords={updateNumOfWords}/>\n      {testFinished ? \n        <Results  initializeNewTest={initializeNewTest} timeToFinishTest={timeToFinish}\n          finishedWordArray={currWordArray} /> \n          :\n        <Typer key={typerInstanceNumber}\n          currArrayOfArrayOfWords={currWordArray} \n            updateTestStart={updateTestStart}\n              updateWordArray={updateWordArray} \n                updateFinish={updateFinish}\n                  initializeNewTest={initializeNewTest}\n                    testFinished={testFinished} \n                      testStarted={testStarted}/>\n      }\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './css/index.css';\nimport './css/media-queries.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}